---
title: "preliminary-results"
output: pdf_document
---

```{r, fig.width = 12, fig.height = 12}
library(data.table)
library(pbmcapply)
library(rtracklayer)
options(mc.cores = parallel::detectCores()/2)
data_dir <- '/nfs/data/IHEC/RNAseq'
rna_data_dir <- file.path(data_dir, 'RNA-Seq')
chip_data_dir <- file.path(data_dir, 'ChIP-Seq')
wgbs_data_dir <- file.path(data_dir, 'WGBS')
```


```{r}
rna_samples <- fread(file.path(data_dir, 'ihec_metadata_rna.csv'))
rna_samples[, epirr_id_wo_version := tstrsplit(epirr_id, '.', fixed = TRUE)[1]]

histone_samples <- fread(file.path(data_dir, 'ihec_metadata.csv'))
histone_samples[, epirr_id_wo_version := tstrsplit(epirr_id, '.', fixed = TRUE)[1]]

histone_samples_available <- sort(unique(gsub("^.*?(IHECRE[0-9]{8}).*$", "\\1", list.files(chip_data_dir, '\\.signal\\.bigwig$'))))

if (length(setdiff(histone_samples[, epirr_id_wo_version], histone_samples_available)) > 0) {
  print(paste('in metadata file but no signal file:', paste(histone_samples[!epirr_id_wo_version %in% histone_samples_available, epirr_id_wo_version], collapse = ', ')))
  print(paste('signal file but not in metadata file:', paste(histone_samples_available[!histone_samples_available %in% histone_samples[, epirr_id_wo_version]], collapse = ', ')))
}

rna_samples_w_chip <- rna_samples[epirr_id_wo_version %in% histone_samples_available]
rna_samples_w_chip <- rna_samples_w_chip[, if(.N > 1){.SD[rna_seq_type != 'total-RNA-Seq']}else{.SD}, by = epirr_id_wo_version]

wgbs_samples <- fread(file.path(data_dir, 'ihec_metadata_wgbs.csv'))
wgbs_samples[, epirr_id_wo_version := tstrsplit(epirr_id, '.', fixed = TRUE)[1]]


wgbs_samples_available <- sort(unique(gsub("^.*?(IHECRE[0-9]{8}).*$", "\\1", list.files(wgbs_data_dir, '\\.gembs_(pos|neg)\\.bw$'))))

if (length(setdiff(wgbs_samples[, epirr_id_wo_version], wgbs_samples_available)) > 0) {
  print(paste('in metadata file but no signal file:', paste(wgbs_samples[!epirr_id_wo_version %in% wgbs_samples_available, epirr_id_wo_version], collapse = ', ')))
  print(paste('signal file but not in metadata file:', paste(wgbs_samples_available[!wgbs_samples_available %in% wgbs_samples[, epirr_id_wo_version]], collapse = ', ')))
}

rna_samples_w_wgbs <- rna_samples[epirr_id_wo_version %in% wgbs_samples_available]
rna_samples_w_wgbs <- rna_samples_w_wgbs[, if(.N > 1){.SD[rna_seq_type != 'total-RNA-Seq']}else{.SD}, by = epirr_id_wo_version]

```


```{r}
rna_w_chip_wgbs <- rna_samples[, epirr_id_wo_version] #intersect(rna_samples_w_chip[, epirr_id_wo_version], rna_samples_w_wgbs[, epirr_id_wo_version])
se <- fread('suppa_analysis/events/TPM1/event_SE.psi')
setnames(se, 'V1', 'event')
se <- se[, c('event', ..rna_w_chip_wgbs)]
se[, ID:=seq.int(.N)]
se[, c('event_name', 'seqnames', 'e1s2', 'e2s3', 'strand') := tstrsplit(event, ':', fixed=TRUE)]
se[, c('gene_id', 'event_type') := tstrsplit(event_name, ';', fixed=T)]
se[, c('start', 'end') := list(as.integer(tstrsplit(e1s2, '-', fixed = TRUE)[[2]]), as.integer(tstrsplit(e2s3, '-', fixed = TRUE)[[1]]))]
se_gr <- se[, GRanges(seqnames = seqnames, ranges = IRanges(start = start, end = end), strand = strand)]

self_hits <- findOverlaps(se_gr, se_gr)
non_overlapping <- self_hits@from[which(!(duplicated(self_hits@from) | duplicated(self_hits@from, fromLast = TRUE)))]
single_genes_only <- se[-se[, grep('_and_', gene_id, fixed = TRUE)], ID]


aggregation_functions <- c('median' = median, 'mean' = mean, 'max' = max)
flank_size <- 150

aggregate_hits <- function(merge_dt, hits, signal_gr, name){
  agg_table <- data.table(ID = hits@from, score = signal_gr[hits@to]$score)[, sapply(aggregation_functions, function(fun) fun(score), simplify = FALSE), by = ID]
  new_names <- paste(name, names(aggregation_functions), sep = '_')
  setnames(agg_table, names(aggregation_functions), new_names)
  merge_dt[agg_table, on = .(ID), (new_names) := mget(new_names)]
  invisible(NULL)
}

aggregate_with_flank <- function(merge_dt, signal_gr, flank_size, name) {
  aggregate_hits(merge_dt, findOverlaps(flank(se_gr, flank_size), signal_gr), signal_gr, paste(name, 'up', flank_size, sep = '_'))
  aggregate_hits(merge_dt, findOverlaps(se_gr, signal_gr), signal_gr, name)
  aggregate_hits(merge_dt, findOverlaps(flank(se_gr, flank_size, start = FALSE), signal_gr), signal_gr, paste(name, 'down', flank_size, sep = '_'))
  invisible(NULL)
}

if (file.exists('se_raw.rds')) {
  se_raw <- readRDS('se_raw.rds')
} else {
gene_quants <- fread('suppa_analysis/gene_expressions.tsv')

se_raw <- pbmcapply::pbmclapply(rna_w_chip_wgbs, function(ihec) {
  # first gather gene expression
  signal_psi_dt <- se[, .(ID, PSI = get(ihec), gene_id)]
  signal_psi_dt[unique(gene_quants[EpiRR_no_version == ihec, .(gene_id, gene_tpm)]), on = .(gene_id), gene := gene_tpm]
  signal_psi_dt[, gene_id := NULL]
  setkey(signal_psi_dt, ID)
  
  # add region_length
  signal_psi_dt[, region_length := width(se_gr)]
  
  # region to cover when importing bigwigs to cover flanks as well
  regions_to_cover <- promoters(se_gr, upstream = flank_size, downstream = flank_size)
  
  # add wgbs
  wgbs_files <- list.files(wgbs_data_dir, ihec)
  if (length(wgbs_files) == 2) {
    wgbs <- Reduce(c, lapply(c('pos', 'neg'), function(strand) {
      wgbs_file <-
        list.files(
          wgbs_data_dir,
          pattern = paste0('.*', ihec, '.*.gembs_', strand, '.bw$'),
          full.names = TRUE
        )
      wgbs_strand <- rtracklayer::import(wgbs_file, which = regions_to_cover)
      strand(wgbs_strand) <- ifelse(strand == 'pos', '+', '-')
      return(wgbs_strand)
    }))
    aggregate_with_flank(signal_psi_dt, wgbs, flank_size, 'wgbs')
  } else if (length(wgbs_files) > 2)
      warning(paste(ihec, 'had > 2 files:', paste(wgbs_files, collapse = ', ')))
    else if (length(wgbs_files) == 0) {
      warning(paste(ihec, 'had 0 files'))
    }
  # add histone marks
  for (this_uuid in histone_samples[epirr_id_wo_version == ihec, uuid]) {
    histone_file <-
        list.files(
          chip_data_dir,
          pattern = paste0('.*', ihec, '.*', this_uuid, '\\.fc\\.signal\\.bigwig$'),
          full.names = TRUE
        )
    if (length(histone_file) > 1)
      warning(paste(ihec, 'had > 1 files for uuid', this_uuid, ':', paste(histone_file, collapse = ', ')))
    else if (length(histone_file) == 0) {
      warning(paste(ihec, 'had 0 files for uuid', this_uuid))
    } else {
      hPTM <- rtracklayer::import(histone_file, which = regions_to_cover)
      aggregate_with_flank(signal_psi_dt, hPTM, flank_size, histone_samples[uuid == this_uuid, antibody])
    }
  }
  signal_psi_dt
})
names(se_raw) <- rna_w_chip_wgbs
saveRDS(se_raw, 'se_raw.rds')
}
```

```{r, fig.width = 12, fig.height = 12}
library(corrplot)
ihec <- 'IHECRE00003808'
event_dt <- se_raw[[ihec]]
aggregation <- 'max'
keep_cols <- function(dt, aggregation_method) {!grepl(paste(names(aggregation_functions)[names(aggregation_functions) != aggregation_method], collapse = '|'), names(dt))}
max_event_cols <- keep_cols(event_dt, aggregation)
event_mat <- as.matrix(event_dt[, ..max_event_cols][, -'ID'])
corrplot(cor(event_mat[intersect(non_overlapping, single_genes_only),], use = 'na', method = 'spearman'))
```


```{r, fig.width = 6, fig.height = 12}
library(pheatmap)
for (entry in se_raw) {
  setnames(entry, names(entry), sub('^reH', 'H', names(entry)))
}
se_dt <- rbindlist(se_raw, idcol = 'IHEC', fill = TRUE)
se_dt[is.nan(PSI), PSI := NA]
cor_dt <- se_dt[ID %in% intersect(non_overlapping, single_genes_only), lapply(.SD[, -c('ID', 'PSI')], function(y) cor(y, PSI, use = 'na', method = 'spearman')), by = 'IHEC']

max_cor_cols <- keep_cols(cor_dt, aggregation)
cor_mat <- as.matrix(cor_dt[, ..max_cor_cols][, -'IHEC'])
rownames(cor_mat) <- cor_dt[, IHEC]
pheatmap(cor_mat[union(rna_samples_w_chip[, epirr_id_wo_version], rna_samples_w_wgbs[, epirr_id_wo_version]), ], color = colorRampPalette(c("red", "white", "blue"))(100), breaks = seq(-1, 1, by = 2/100))
```

```{r}
se_max_cols <- keep_cols(se_dt, aggregation)
feature_data <- se_dt[, ..se_max_cols][, -c('IHEC', 'ID')]
response <- 'PSI'
explanatory <- names(feature_data)[names(feature_data) != response]
feature_data[, (names(feature_data)) := lapply(names(feature_data), function(x) scale(get(x)))]
lm(formula(paste(response, '~', paste(explanatory, collapse = ' + '))), feature_data)
```

