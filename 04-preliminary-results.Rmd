---
title: "preliminary-results"
output: pdf_document
---

```{r, eval=FALSE}
# first get all rna, histone and wgbs data to match the samples
rna_samples <- fread(file.path(data_dir, 'ihec_metadata_rna.csv'))
rna_samples[, epirr_id_wo_version := tstrsplit(epirr_id, '.', fixed = TRUE)[1]]
downloaded_rna_samples <- sort(unique(gsub("^.*?(IHECRE[0-9]{8}).*$", "\\1", list.files(rna_data_dir, pattern = '\\.isoforms\\.results$'))))

histone_samples <- fread(file.path(data_dir, 'ihec_metadata.csv'))
histone_samples[, epirr_id_wo_version := tstrsplit(epirr_id, '.', fixed = TRUE)[1]]

downloaded_histone_samples <- sort(unique(gsub("^.*?(IHECRE[0-9]{8}).*$", "\\1", list.files(chip_data_dir, '\\.(fc\\.signal\\.bigwig|pval0\\.01\\.500K\\.bfilt\\.narrowPeak\\.gz)$'))))
# 
# if (length(setdiff(histone_samples[, epirr_id_wo_version], downloaded_histone_samples)) > 0) {
#   print(paste('in metadata file but no signal file:', paste(histone_samples[!epirr_id_wo_version %in% downloaded_histone_samples, epirr_id_wo_version], collapse = ', ')))
#   print(paste('signal file but not in metadata file:', paste(downloaded_histone_samples[!downloaded_histone_samples %in% histone_samples[, epirr_id_wo_version]], collapse = ', ')))
# }

rna_samples_w_chip <- rna_samples[epirr_id_wo_version %in% downloaded_histone_samples]
# there are some sample where there is mRNA and total-RNA-Seq. in that case we take mRNA-Seq
rna_samples_w_chip <- rna_samples_w_chip[, if(.N > 1){.SD[rna_seq_type != 'total-RNA-Seq']}else{.SD}, by = epirr_id_wo_version]

wgbs_samples <- fread(file.path(data_dir, 'ihec_metadata_wgbs.csv'))
wgbs_samples[, epirr_id_wo_version := tstrsplit(epirr_id, '.', fixed = TRUE)[1]]


downloaded_wgbs_samples <- sort(unique(gsub("^.*?(IHECRE[0-9]{8}).*$", "\\1", list.files(wgbs_data_dir, '\\.gembs_(pos|neg)\\.bw$'))))

# if (length(setdiff(wgbs_samples[, epirr_id_wo_version], wgbs_samples_available)) > 0) {
#   print(paste('in metadata file but no signal file:', paste(wgbs_samples[!epirr_id_wo_version %in% wgbs_samples_available, epirr_id_wo_version], collapse = ', ')))
#   print(paste('signal file but not in metadata file:', paste(wgbs_samples_available[!wgbs_samples_available %in% wgbs_samples[, epirr_id_wo_version]], collapse = ', ')))
# }

rna_samples_w_wgbs <- rna_samples[epirr_id_wo_version %in% downloaded_wgbs_samples]
# there are some sample where there is mRNA and total-RNA-Seq. in that case we take mRNA-Seq
rna_samples_w_wgbs <- rna_samples_w_wgbs[, if(.N > 1){.SD[rna_seq_type != 'total-RNA-Seq']}else{.SD}, by = epirr_id_wo_version]

samples_with_epi <- intersect(downloaded_rna_samples, intersect(downloaded_histone_samples, downloaded_wgbs_samples))

```

```{r}
psi_input_dir <- "suppa_analysis/events"
header <- readLines('suppa_analysis/tpm_expressions.tsv', n=1)
sample_cols <- strsplit(header, '\t', TRUE)[[1]]
# all_event_files <- list.files(psi_input_dir, pattern = paste0('[^', paste(as_events, collapse = '|'), ']\\.psi$'), full.names = TRUE)
# all_event_dt <- rbindlist(sapply(all_event_files, fread, simplify=FALSE))
# setnames(other_event_dt, 'V1', 'event')
event_res <- sapply(as_events, function(event_type) {
	# load psi values
  event_dt <- fread(paste0(psi_input_dir, '/event_', event_type, '.psi'))
  setnames(event_dt, 'V1', 'event_id')
  # # get all the samples that are also in the metadata and filter
  # event_dt <- event_dt[, c('event', ..samples_with_epi)]
  # # remove all the events where there is only one valid value. They would be discarded later anyway
  # event_dt <- event_dt[apply(event_dt[, ..sample_cols], 1, function(r) sum(is.na(r)) < (length(r) - 1)), ]
  
  # prepare the alternative/upstream/downstream region
  if (event_type == 'SE') {
    event_dt[, c('event_name', 'seqnames', 'e1s2', 'e2s3', 'strand') := tstrsplit(event_id, ':', fixed=TRUE)]
    event_dt[, c('gene_id', 'event_type') := tstrsplit(event_name, ';', fixed=T)]
    event_dt[, c('e1', 's2', 'e2', 's3') := c(tstrsplit(e1s2, '-', fixed = TRUE, type.convert = TRUE), tstrsplit(e2s3, '-', fixed = TRUE, type.convert = TRUE))]
    all_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = e1, end = s3), strand = strand)]
    upstream_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = ifelse(strand == '+', e1, e2), end = ifelse(strand == '+', s2, s3)), strand = strand)]
    downstream_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = ifelse(strand == '+', e2, e1), end = ifelse(strand == '+', s3, s2)), strand = strand)]
    event_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = s2, end = e2), strand = strand)]
  } else if (event_type == 'RI') {
    event_dt[, c('event_name', 'seqnames', 's1', 'e1s2', 'e2', 'strand') := tstrsplit(event_id, ':', fixed=TRUE, type.convert = TRUE)]
    event_dt[, c('gene_id', 'event_type') := tstrsplit(event_name, ';', fixed=T)]
    event_dt[, c('e1', 's2') := tstrsplit(e1s2, '-', fixed = TRUE, type.convert = TRUE)]
    all_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = s1, end = e2), strand = strand)]
    upstream_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = ifelse(strand == '+', s1, s2), end = ifelse(strand == '+', e2, e2)), strand = strand)]
    downstream_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = ifelse(strand == '+', s2, s1), end = ifelse(strand == '+', e2, e1)), strand = strand)]
    event_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = e1, end = s2), strand = strand)]
  } else if (event_type %in% c('AL', 'AF')){
    event_dt[, c('event_name', 'seqnames', 's1/e1s2', 'e1s3/e2', 's2/e1s3', 'e2s3/e3', 'strand') := tstrsplit(event_id, ':', fixed=TRUE, type.convert = TRUE)]
    event_dt[, c('gene_id', 'event_type') := tstrsplit(event_name, ';', fixed=T)]
    event_dt[ifelse(event_type=='AF', strand == '+', strand == '-'), start_all:=as.integer(`s1/e1s2`)]
    event_dt[ifelse(event_type=='AF', strand == '-', strand == '+'), start_all:=tstrsplit(`s1/e1s2`, '-', fixed=TRUE, type.convert = TRUE)[[1]]]
    
    event_dt[ifelse(event_type=='AF', strand == '-', strand == '+'), end_all:=as.integer(`e2s3/e3`)]
    event_dt[ifelse(event_type=='AF', strand == '+', strand == '-'), end_all:=tstrsplit(`e2s3/e3`, '-', fixed=TRUE, type.convert = TRUE)[[2]]]
    all_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = start_all, end = end_all), strand = strand)]
    upstream_gr <- NULL
    downstream_gr <- NULL
    event_gr <- NULL
  } else if (event_type %in% c('A3', 'A5')){
    event_dt[, c('event_name', 'seqnames', 'e1s2/e2s3', 'e1s3', 'strand') := tstrsplit(event_id, ':', fixed=TRUE, type.convert = TRUE)]
    event_dt[, c('gene_id', 'event_type') := tstrsplit(event_name, ';', fixed=T)]
    event_dt[, c('e1/e2', 's2/s3') := tstrsplit(`e1s2/e2s3`, '-', fixed = TRUE, type.convert = TRUE)]
    event_dt[, c('e1', 's3') := tstrsplit(e1s3, '-', fixed = TRUE, type.convert = TRUE)]
    all_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = `e1/e2`, end = s3), strand = strand)]
    upstream_gr <- NULL
    downstream_gr <- NULL
    event_gr <- NULL
  } else if (event_type == 'MX'){
    event_dt[, c('event_name', 'seqnames', 'e1s2', 'e2s4', 'e1s3', 'e3s4', 'strand') := tstrsplit(event_id, ':', fixed=TRUE, type.convert = TRUE)]
    event_dt[, c('gene_id', 'event_type') := tstrsplit(event_name, ';', fixed=T)]
    event_dt[, start_all:=tstrsplit(e1s2, '-', fixed=TRUE, type.convert = TRUE)[[1]]]
    event_dt[, end_all:=tstrsplit(e3s4, '-', fixed=TRUE, type.convert = TRUE)[[2]]]
    all_gr <- event_dt[, GRanges(seqnames = seqnames, ranges = IRanges(start = start_all, end = end_all), strand = strand)]
    upstream_gr <- NULL
    downstream_gr <- NULL
    event_gr <- NULL
  } else stop('unknown event')
  
  list(event_dt = event_dt[, c('event_id', 'gene_id', 'seqnames', 'strand', ..sample_cols)], event_gr = event_gr, upstream_gr = upstream_gr, downstream_gr = downstream_gr, all_gr=all_gr)
}, simplify = FALSE)
```

```{r, fig.width=7, fig.height=7}
library(ggvenn)

all_gr <- Reduce(c, lapply(event_res, function(event){event$all_gr}))

# merge event_dts and gr objects. adjust IDs
max_ID <- 0L
event_dt <- data.table()
event_gr <- GRanges()
upstream_gr <- GRanges()
downstream_gr <- GRanges()
for (event_name in to_analyze) {
  this_dt <- copy(event_res[[event_name]]$event_dt)
  this_event_gr <- event_res[[event_name]]$event_gr
  single_genes_only <- this_dt[!grepl('_and_', gene_id, fixed = TRUE), which = TRUE]
  # var_events[[event_name]] <- sapply(var_events[[event_name]], function(ids) ids + max_ID, simplify = FALSE)
  
  other_event_overlaps <- findOverlaps(this_event_gr, all_gr)
  non_overlapping_other <- other_event_overlaps@from[which(!(duplicated(other_event_overlaps@from) | duplicated(other_event_overlaps@from, fromLast = TRUE)))]
  self_event_overlaps <- findOverlaps(this_event_gr)
  non_overlapping_self <- self_event_overlaps@from[which(!(duplicated(self_event_overlaps@from) | duplicated(self_event_overlaps@from, fromLast = TRUE)))]  
  print(ggvenn(list('all'=this_dt[, seq.int(.N)],'overlap\nother'=non_overlapping_other, 'overlap\nself'=non_overlapping_self, 'single\ngene'=single_genes_only)) + labs(title = event_name))

  # keep_rows <- intersect(single_genes_only, non_overlapping_other)
  # add ID
  # this_dt <- this_dt[keep_rows]
  # this_dt[, ID:=seq.int(.N)]
  
  # this_max_ID <- this_dt[, max(ID)]
  
  event_gr <- c(event_gr, this_event_gr)#[keep_rows])
  upstream_gr <- c(upstream_gr, event_res[[event_name]]$upstream_gr)#[keep_rows])
  downstream_gr <- c(downstream_gr, event_res[[event_name]]$downstream_gr)#[keep_rows])
  # this_dt[, ID := ID + max_ID]
  this_dt[, event_name := event_name]
  event_dt <- rbind(event_dt, this_dt)
  # max_ID <- max_ID + this_max_ID
}
event_dt[, ID:=seq.int(.N)]

other_event_overlaps <- findOverlaps(event_gr, all_gr)
non_overlapping_other <- other_event_overlaps@from[which(!(duplicated(other_event_overlaps@from) | duplicated(other_event_overlaps@from, fromLast = TRUE)))]

single_genes_only <- event_dt[!grepl('_and_', gene_id, fixed = TRUE), which = TRUE]

keep_rows <- intersect(single_genes_only, non_overlapping_other)

stopifnot(identical(event_dt[, ID], seq(nrow(event_dt))))# && max_ID == event_dt[, max(ID)])
cols_to_factor <- c('event_id', 'gene_id', 'seqnames', 'strand', 'event_name')
event_dt[,(cols_to_factor) := lapply(.SD, as.factor), .SDcols = cols_to_factor] 
saveRDS(event_res, 'event_res.rds')
rm(event_res)
```

```{r, fig.width = 12, fig.height = 12}
library(pheatmap)

var_events <- sapply(to_analyze, function(event) {
  this_event_dt <- event_dt[event_name == event]
  event_mat <- as.matrix(this_event_dt[ID %in% keep_rows, ..sample_cols])
  rownames(event_mat) <- this_event_dt[ID %in% keep_rows, ID]
  event_mat[is.nan(event_mat)] <- NA
  na_count <- apply(event_mat, 1, function(r) sum(is.na(r))) # < (length(r) - 1)))
  na_percentage <- na_count / length(sample_cols)
  
  # check event psi variation
  event_psi_sd <- apply(event_mat, 1, sd, na.rm = TRUE)
  # hist(event_psi_sd, 30, main = event)
  print(ggplot(data.table(sd = event_psi_sd, na_percentage=na_percentage), aes(x = na_percentage, y = sd)) + geom_point() + labs(title=event, x=paste0('na percentage (overall ', length(sample_cols), ')')) + theme_bw())
  quants <- seq(0, .9, .1)
  var_events <- sapply(quants, function(quant) {
    threshold <- quantile(event_psi_sd, quant, na.rm=TRUE)
    var_events <- rownames(event_mat)[which(event_psi_sd >= threshold)]
  })
  names(var_events) <- quants
  
  
  print(pheatmap(event_mat, show_colnames = FALSE, show_rownames = FALSE, main = event, cluster_rows = FALSE, cluster_cols = FALSE))
  rmv <- apply(event_mat, 1, function(r) sum(is.na(r)) > length(r)/2)
  print(pheatmap(event_mat[intersect(var_events[['0.5']], names(rmv)[!rmv]), ], show_colnames = FALSE, main = paste(event, '0.5 var threshold')))
  var_events
}, simplify = FALSE)
```

```{r}
library(ggplot2)
ggplot(melt(event_dt[ID %in% keep_rows, sapply(sample_cols, function(x) sum(is.nan(get(x)))/.N, simplify = FALSE), by = event_name], measure.vars = sample_cols, variable.name = 'IHEC', value.name = 'na_proportion'), aes(x = event_name, y = na_proportion)) + geom_violin() + labs(title = 'na proportion by samples')
# melt(event_dt, id.vars = c('ID', 'gene_id', 'seqnames', 'strand', 'event_name'), variable.name = 'IHEC', value.name = 'PSI')
ggplot(melt(event_dt[ID %in% keep_rows], id.vars = c('ID', 'gene_id', 'seqnames', 'strand', 'event_name'), measure.vars = sample_cols, variable.name = 'IHEC', value.name = 'PSI')[, .(na_proportion=sum(is.nan(PSI))/.N), by = .(ID, event_name)], aes(x = event_name, y = na_proportion)) + geom_violin() + labs(title = 'na proportion by events')
ggplot(melt(event_dt[ID %in% keep_rows], id.vars = c('ID', 'gene_id', 'seqnames', 'strand', 'event_name'), measure.vars = sample_cols, variable.name = 'IHEC', value.name = 'PSI')[, .(na_proportion=sum(is.nan(PSI))/(.N)), by = .(ID, event_name)], aes(x = na_proportion)) + facet_wrap(. ~ event_name, scales = 'free') + stat_ecdf() + labs(title = 'na proportion by events')
```

```{r}
aggregated_file_path <- file.path(psi_input_dir, 'aggregated_reference.rds')
save.image('aggregating.rda')
```


```{r}
annotation <- import('suppa_analysis/gencode.v29.annotation.gtf')
used_genes <- annotation[annotation$gene_id %in% event_dt[, gene_id] & annotation$type == 'gene', ]
event_dt[data.table(gene_id = used_genes$gene_id, gene_start = start(used_genes), gene_end = end(used_genes)), on = 'gene_id', c('gene_start', 'gene_end') := .(gene_start, gene_end)]

event_dt[strand == '-', distance_TSS:=gene_end - end(event_gr[ID])]
event_dt[strand != '-', distance_TSS:=start(event_gr[ID]) - gene_start]

event_dt[strand == '-', distance_TES:=start(event_gr[ID]) - gene_start]
event_dt[strand != '-', distance_TES:=gene_end - end(event_gr[ID])]

# add stats about enhancers
# signal_psi_dt[, count_enhancer := as.integer(table(c(signal_psi_dt[, ID], from(enhancer_hits)))) - 1L]
    
# signal_psi_dt[data.table(ID = from(distances_enhancers), distance = mcols(distances_enhancers)$distance), on = .(ID), distance_enhancer := distance]

# load gene quantifications
gene_quants <- readRDS('suppa_analysis/gene_expressions.rds')

# separator_gene_ids <- '_and_'
# signal_psi_dt <- event_dt[, .(ID, PSI = get(ihec), gene_id)]
# signal_psi_dt <- signal_psi_dt[, .(gene_id = unlist(tstrsplit(gene_id, separator_gene_ids, fixed=TRUE))), by=.(ID, PSI)]
# signal_psi_dt[unique(gene_quants[EpiRR_no_version == ihec, .(gene_id, gene_tpm)]), on = .(gene_id), gene_expression := gene_tpm]
# signal_psi_dt <- signal_psi_dt[, .(gene_id=paste(gene_id, collapse=separator_gene_ids), gene_expression=sum(gene_expression, na.rm = TRUE)), by=.(ID, PSI)]

    
# add region_lengths
event_dt[, paste('width', 'upstream_other_region', sep = ';') := width(upstream_gr)]
event_dt[, paste('width', 'event_name', sep = ';') := width(event_gr)]
event_dt[, paste('width', 'downstream_other_region', sep = ';') := width(downstream_gr)]

# add distance to TSS and TES here
# signal_psi_dt[, distance_TSS := distance_TSS]
# signal_psi_dt[width(promoter_gr) == 1, distance_TSS := NA] # no distance for multi-gene-exons
# signal_psi_dt[, distance_TES := distance_TES]
# signal_psi_dt[width(tes_gr) == 1, distance_TES := NA] # no distance for multi-gene-exons

```

```{r}
metadata <- data.table::fread('IHEC_metadata_harmonization.v0.9.extended.csv')
metadata[, EpiRR_no_version := data.table::tstrsplit(EpiRR, '.', fixed = TRUE)[1]]
metadata[, annotation := sample_ontology_term_high_order_manual]
# metadata[biomaterial_type == 'primary tissue', annotation := tissue_type]
# metadata[biomaterial_type == 'cell line', annotation := line]
# metadata[annotation == "CD34-positive, CD38-positive common myeloid progenitor OR CD34-positive, CD38-positive common lymphoid progenitor", annotation := "CD34-positive, CD38-positive common progenitor"]
```


```{r}
# if (!file.exists(aggregated_file_path)) {
#   source('04-preliminary-results-aggregation.R') # or run with sbatch 04-preliminary-results-aggregation.sh
# }
# 
# aggregated_data <- readRDS(aggregated_file_path)

# at some point rename event_name and other_region with ifelse(event_name == 'SE', 'intron', 'exon')

# aggregated_data <- aggregated_data[sample_cols]
```

```{r, fig.width=16, fig.height=10}
agg_data_files <- list.files(file.path(psi_input_dir, 'sample_dts'), pattern = 'merge_dt.csv.gz', full.names = TRUE)
histone_marks <- c('H3K4me1', 'H3K27me3', 'H3K36me3', 'H3K27ac', 'H3K4me3', 'H3K9me3')
cCRE_regions <- c('CTCF-only', 'dELS', 'pELS', 'PLS', 'DNase-H3K4me3')
cCRE_regions <- c(cCRE_regions, paste(cCRE_regions, 'CTCF-bound', sep = ','))
genomic_regions <- c('upstream_other_region', 'event_name', 'downstream_other_region')
all_regions <- c(cCRE_regions, genomic_regions)
histone_cols <- paste(CJ(histone_marks, all_regions)[, paste(histone_marks, all_regions, sep=';')], 'max', sep = ';')
wgbs_cols <- paste('wgbs', all_regions, 'mean', sep = ';')
cols_to_read <- c('ID', histone_cols, wgbs_cols)
file2IHEC <- tstrsplit(basename(agg_data_files), '-', fixed=TRUE, keep = 1)[[1]]
names(file2IHEC) <- agg_data_files
aggregated_dt <- rbindlist(suppressWarnings(sapply(agg_data_files, fread, select = cols_to_read)), idcol = 'IHEC', fill = TRUE)
aggregated_dt[, IHEC:= as.factor(file2IHEC[IHEC])]
# for (entry in aggregated_data) {
#   if (any(duplicated(sub('^reH', 'H', names(entry))))) {
#     drop_cols <- names(entry)[startsWith(names(entry), 're') & (duplicated(sub('^reH', 'H', names(entry))) | duplicated(sub('^reH', 'H', names(entry)), last = TRUE))]
#     entry[, (drop_cols):=NULL]
#   }
#   setnames(entry, names(entry), sub('^reH', 'H', names(entry)))
#   rare_antibodies <- names(entry)[grep('H3K9/14ac|H2A\\.Zac', names(entry))]
#   entry[, (rare_antibodies):=NULL]
#   # setnames(entry, names(entry), gsub(' ', '_', names(entry), fixed = TRUE))
# }
# aggregated_dt <- rbindlist(aggregated_data, idcol = 'IHEC', fill = TRUE)
# rm(aggregated_data)
# aggregated_dt[, IHEC:=as.factor(IHEC)]
aggregated_dt <- aggregated_dt[ID %in% keep_rows]
# aggregated_dt <- aggregated_dt[!is.nan(PSI)]
gc()

# if (!file.exists('aggregated_dt.rds'))
# saveRDS(aggregated_dt, 'aggregated_dt.rds')
fwrite(aggregated_dt, 'aggregated_dt.csv.gz')
```

```{r, eval=FALSE}
wgbs_cols <- names(aggregated_dt)[startsWith(names(aggregated_dt), 'wgbs;') & endsWith(names(aggregated_dt), ';mean') & !endsWith(names(aggregated_dt), 'tile;mean')]
hPTM_cols <- names(aggregated_dt)[!startsWith(names(aggregated_dt), 'wgbs;') & endsWith(names(aggregated_dt), ';max') & !endsWith(names(aggregated_dt), 'tile;max')]
cols_to_delete <- names(aggregated_dt)[!names(aggregated_dt) %in% c(wgbs_cols, hPTM_cols, 'IHEC', 'ID')]
aggregated_dt[, (cols_to_delete):=NULL]
```

```{r, eval = FALSE}
enhancers_counts <- dcast(aggregated_dt, ID + event ~ IHEC, value.var = 'count_enhancer')
stopifnot(all(apply(enhancers_counts[, ..sample_cols], 1, FUN = function(row) length(unique(row[!is.na(row)])) == 1)))
ggplot(enhancers_counts, aes(x = IHECRE00000001)) + facet_wrap(. ~ event) + stat_ecdf()
```

```{r, fig.width=16, fig.height=10}
melted_psi <- melt(event_dt, measure.vars = sample_cols, id.vars = 'ID', variable.name = 'IHEC', value.name = 'PSI')
aggregated_dt[melted_psi[ID %in% keep_rows & !is.na(PSI)], on=.(ID, IHEC), PSI:=PSI]
aggregated_dt <- aggregated_dt[!is.na(PSI)]

cols_to_add <- c('gene_id', 'distance_TSS', 'distance_TES', 'width;upstream_other_region', 'width;event_name', 'width;downstream_other_region', 'event_name')
aggregated_dt[event_dt, on=.(ID), (cols_to_add):=mget(cols_to_add)]
aggregated_dt[gene_quants, on=.(gene_id), gene_expression:=gene_tpm]
aggregated_dt[, gene_expression:=log2(gene_expression + 1)]
aggregated_dt[, gene_id:=NULL]

# if (!file.exists('aggregated_dt_filtered.rds'))
# saveRDS(aggregated_dt, 'aggregated_dt_filtered.rds')
fwrite(aggregated_dt, 'aggregated_dt_filtered.csv.gz')

# aggregated_dt[metadata, on=c(IHEC='EpiRR_no_version'), annotation:=annotation]
# cols_to_add <- c(cols_to_add, 'PSI')


for (this_event in to_analyze) 
print(ggplot(aggregated_dt[event_name == this_event & IHEC %in% aggregated_dt[, sample(unique(IHEC), size = 16)]], aes(x = PSI)) + geom_histogram(color = 'white', binwidth = .05) + theme_bw() + facet_wrap(. ~ IHEC) + labs(title = this_event))
```

```{r, fig.width=16, fig.height=10}
unlisted_vars <- unlist(unname(var_events), recursive = FALSE)

minimum_events <- 25

cor_dt <-
  rbindlist(setNames(pbmclapply(unique(
    names(unlisted_vars)
  ), function(var) {
    print(var)
    var_ids <-
      as.integer(unlist(unlisted_vars[names(unlisted_vars) == var], use.names = FALSE))
    rbindlist(sapply(cor_methods, function(cor_method)
      aggregated_dt[ID %in% var_ids, lapply(.SD, function(y) {
        rmv <- is.na(y) | is.na(PSI)
        res <- NA
        if ((length(rmv) - sum(rmv)) >= 25)
          res <-
          suppressWarnings(stats::cor(PSI, y, use = 'pairwise', method = cor_method))
        return(as.numeric(res))
      }), by = .(event_name, IHEC), .SDcols = names(aggregated_dt)[!names(aggregated_dt) %in% c('ID', 'PSI', 'IHEC', 'event_name')]]
      , simplify = FALSE),
      idcol = 'cor_method')
  }), unique(names(unlisted_vars))), idcol = 'variance_quartile')
cor_dt[, variance_quartile := as.factor(variance_quartile)]
cor_dt[, cor_method := as.factor(cor_method)]
cor_dt[, partial := FALSE]


pcor_dt <-
  rbindlist(setNames(pbmclapply(unique(
    names(unlisted_vars)
  ), function(var) {
    print(var)
    var_ids <-
      as.integer(unlist(unlisted_vars[names(unlisted_vars) == var], use.names = FALSE))
    rbindlist(sapply(cor_methods, function(cor_method)
      aggregated_dt[ID %in% var_ids, lapply(.SD, function(y) {
        rmv <- is.na(y) | is.na(PSI) | is.na(gene_expression)
        res <- NA
        if ((length(rmv) - sum(rmv)) >= 25)
          res <- tryCatch(
            suppressWarnings(ppcor::pcor.test(PSI[!rmv], y[!rmv], gene_expression[!rmv], method = cor_method)$estimate),
            error = function(e) {
              if (identical(y, gene_expression) &
                  startsWith(e$message, prefix = 'system is computationally singular'))
                return(suppressWarnings(stats::cor(y, PSI, use = 'pairwise', method = cor_method)))
              return(e)
            }
          )
        return(as.numeric(res))
      }), by = .(event_name, IHEC), .SDcols = names(aggregated_dt)[!names(aggregated_dt) %in% c('ID', 'PSI', 'IHEC', 'event_name')]]
      , simplify = FALSE),
      idcol = 'cor_method')
  }), unique(names(unlisted_vars))), idcol = 'variance_quartile')
pcor_dt[, variance_quartile := as.factor(variance_quartile)]
pcor_dt[, cor_method := as.factor(cor_method)]
pcor_dt[, partial := TRUE]


all_cor <- rbind(cor_dt, pcor_dt)

for (this_event in to_analyze) {
  var_events_type <- var_events[[this_event]]
  for (var_threshold in names(var_events_type)) {
    for (this_cor_method in cor_methods) {
      for (this_partial in c(TRUE, FALSE)) {
        cor_dt_event_var <-
          all_cor[event_name == this_event &
                    variance_quartile == var_threshold &
                    cor_method == this_cor_method &
                    partial == this_partial]
        cor_mat <-
          as.matrix(cor_dt_event_var[,-c('IHEC',
                                         'event_name',
                                         'variance_quartile',
                                         'partial',
                                         'cor_method')])
        rownames(cor_mat) <- cor_dt_event_var[, IHEC]
        breaks <- seq(-.4, .4, by = .05)
        annotation_df <-
          metadata[EpiRR_no_version %in% sample_cols, data.frame(annotation = annotation, row.names = EpiRR_no_version)]
        tryCatch({
          pheatmap(
            t(cor_mat[sample_cols,])[, rownames(annotation_df)[order(annotation_df$annotation)]],
            color = colorRampPalette(c("red", "white", "blue"))(length(breaks)),
            breaks = breaks,
            annotation_col = annotation_df,
            cluster_cols = FALSE,
            cluster_rows = FALSE,
            main = paste(
              this_event,
              ':',
              this_cor_method,
              ', PSI Variance Quantile:',
              var_threshold,
              ', partial',
              this_partial
            ),
            na_col = 'grey',
            show_colnames = FALSE
          )
        }, error = function(e) {
          print(paste(this_event, var_threshold, e$message))
        })
      }
    }
  }
}
```


```{r, fig.width=8, fig.height=6}
cor_dt_intermediate <- copy(all_cor)
colnames(cor_dt_intermediate) <- gsub(';max', '', colnames(cor_dt_intermediate), fixed = TRUE)
colnames(cor_dt_intermediate) <- gsub(';mean', '', colnames(cor_dt_intermediate), fixed = TRUE)
melt_cor_dt <- melt(cor_dt_intermediate, id.vars = c('IHEC', 'event_name', 'variance_quartile', 'partial', 'cor_method'), variable.name = 'feature', value.name = 'correlation w/ PSI')
melt_cor_dt[event_name == 'SE', feature := gsub('other_region', 'intron', feature, fixed=TRUE)]
melt_cor_dt[event_name == 'RI', feature := gsub('other_region', 'exon', feature, fixed=TRUE)]
melt_cor_dt[event_name == 'SE', feature := gsub('event_name', 'SE', feature, fixed=TRUE)]
melt_cor_dt[event_name == 'RI', feature := gsub('event_name', 'RI', feature, fixed=TRUE)]
melt_cor_dt[, feature:=sub(';', ' in ', feature, fixed = TRUE)]
melt_cor_dt[, feature:=gsub('_', ' ', feature, fixed = TRUE)]
aggregate_median_by <- c('feature', 'event_name', 'variance_quartile', 'partial', 'cor_method')
melt_cor_dt[, median_cor:=median(`correlation w/ PSI`, na.rm = TRUE), by = aggregate_median_by]
melt_cor_dt[, relevant:=any(abs(median_cor) > .1), by = aggregate_median_by]

# subset_cor_dt <- melt_cor_dt[variance_quartile %in% c('0', '0.5')]
# subset_cor_dt[, relevant := any(relevant), by = .(feature, event_name)]

for (color_by in c('partial', 'cor_method')) {
  find_relevant_by <- aggregate_median_by[aggregate_median_by != color_by]
  melt_cor_dt[, plot_relevant:=any(relevant), by = mget(find_relevant_by)]
  breaks <- seq(-.5, .5, by = .1)
  not_color_by <- TRUE
  if (color_by == 'partial')
    not_color_by <- melt_cor_dt[, cor_method == 'spearman']
  else if (color_by == 'cor_method')
    not_color_by <- melt_cor_dt[, partial == 'TRUE']
  p <- ggplot(melt_cor_dt[plot_relevant == TRUE & variance_quartile == '0' & not_color_by], 
               aes(x = `correlation w/ PSI`, 
                   y =  tidytext::reorder_within(feature, -median_cor, event_name), 
                   color = get(color_by))) + 
          theme_bw() +
          geom_boxplot(aes(fill = median_cor)) + 
          scale_fill_gradientn(colours = colorRampPalette(c("red", "white", "blue"))(length(breaks)), breaks = breaks, limits = c(min(breaks), max(breaks))) +
          scale_colour_manual(values = c('dark grey', 'black'), name = color_by) +
          labs(y = 'aggregated signal in or statistic of region') + #, title = 'Distribution of (partial) pearson correlation of epigenetic signals and the PSI (percent spliced ) across all events and samples') +
          tidytext::scale_y_reordered() + 
          facet_wrap(. ~ event_name, scales="free")
  print(p)
}
```


```{r, fig.width=10, fig.height=10}
dcast(all_cor, formula = variance_quartile + cor_method + IHEC + event_name ~ partial, value.var = 'gene_expression')[`FALSE` - `TRUE` > 1e-10]
test_dt <- aggregated_dt[event_name == 'SE' & ID %in% as.integer(unlist(unlisted_vars[names(unlisted_vars) == '0'], use.names = FALSE)) & IHEC == 'IHECRE00000277']
test_dt[, cor(PSI, gene_expression, use = 'pairwise', 'spearman')]
test_dt[!(is.na(PSI) | is.na(gene_expression)), ppcor::pcor.test(gene_expression, PSI, gene_expression, 'spearman')]
test_dt[!(is.na(PSI) | is.na(gene_expression)), ppcor::pcor.test(PSI, gene_expression, gene_expression, 'spearman')]
```

```{r, fig.width=10, fig.height=10}
library(patchwork)
p <- ggplot(aggregated_dt[event_name == 'SE' & ID %in% as.integer(unlist(unlisted_vars[names(unlisted_vars) == '0'], use.names = FALSE)) & IHEC == 'IHECRE00000060'], aes(x = `width;event_name`, y = PSI, color = event_name)) + facet_wrap(. ~ IHEC) +  geom_point() +
  ggpubr::stat_cor(colour = "black")+ ggpubr::stat_cor(method='spearman', cor.coef.name = 'rho', label.y.npc = 'bottom', colour = "black")
p1 <- ggplot(aggregated_dt[event_name == 'SE' & ID %in% as.integer(unlist(unlisted_vars[names(unlisted_vars) == '0'], use.names = FALSE)) & IHEC == 'IHECRE00000060'], aes(x = `width;event_name`, y = PSI, color = event_name)) + facet_wrap(. ~ IHEC) +  geom_point() + scale_x_log10() + 
  ggpubr::stat_cor(colour = "black")+ ggpubr::stat_cor(method='spearman', cor.coef.name = 'rho', label.y.npc = 'bottom', colour = "black")
p + p1
```


```{r, fig.width = 12, fig.height = 12, eval=FALSE}
library(corrplot)
ihec <- 'IHECRE00001878'
this_event_dt <- aggregated_data[[ihec]]
names(this_event_dt) <- gsub(' ', '_', names(this_event_dt), fixed = TRUE)
max_event_cols <- keep_cols(this_event_dt, aggregation)
max_event_cols <- !endsWith(names(this_event_dt), 'percentage') & max_event_cols
event_mat <- as.matrix(this_event_dt[, ..max_event_cols][, -'ID'])
event_mat[is.nan(event_mat)] <- NA
colnames(event_mat) <- gsub('_max', '', colnames(event_mat), fixed = TRUE)
event_mat[, 'gene_expression'] <- log2(event_mat[, 'gene_expression'] + 1)
for (event_type in names(var_events)) {
  var_events_type <- var_events[[event_type]]
  for (var_threshold in names(var_events_type)){
    for (cor_method in c('pearson', 'spearman'))
      corrplot(cor(event_mat[intersect(var_events_type[[var_threshold]], single_genes_non_overlapping),], use = 'na', method = cor_method), order = 'hclust', title = paste0('\n\n', ihec, '\n', event_type, ' variace_threshold: ', var_threshold))
  }
}
```

```{r, eval=FALSE}
library(kohonen)
for (event_name in aggregated_dt_intermediate[, unique(event)]) {
  
  # x <- as.matrix(aggregated_dt_intermediate[event == event_name & ID %in% non_overlapping, -c('IHEC', 'ID', 'PSI', 'event')])
  # y <- aggregated_dt_intermediate[event == event_name & ID %in% non_overlapping, PSI]
  # som <- xyf(x, y, mode = 'pbatch', cores = ncores)
  
  feature_data <- aggregated_dt_intermediate[event == event_name & ID %in% non_overlapping, -c('IHEC', 'ID', 'event')]
  response <- 'PSI'
  explanatory <- names(feature_data)[names(feature_data) != response]
  feature_data[, (names(feature_data)) := lapply(names(feature_data), function(x) scale(get(x)))]
  linear_model <- lm(formula(paste(response, '~', paste(explanatory, collapse = ' + '))), feature_data)
  summary(linear_model)
}
aggregated_dt_intermediate
```

```{r, fig.width = 18, fig.height = 8, eval=FALSE}
library(pheatmap)
library(ggplot2)
for (entry in se_raw) {
  if (any(duplicated(sub('^reH', 'H', names(entry))))) {
    drop_cols <- names(entry)[startsWith(names(entry), 're') & (duplicated(sub('^reH', 'H', names(entry))) | duplicated(sub('^reH', 'H', names(entry)), last = TRUE))]
    entry[, (drop_cols):=NULL]
  } else {
    setnames(entry, names(entry), sub('^reH', 'H', names(entry)))
  }
  setnames(entry, names(entry), gsub(' ', '_', names(entry), fixed = TRUE))
}
se_dt <- rbindlist(se_raw, idcol = 'IHEC', fill = TRUE)
se_dt[, gene_expression:=log2(gene_expression + 1)]
se_dt[is.nan(PSI), PSI := NA]
ggplot(se_dt[IHEC %in% se_dt[, sample(unique(IHEC), size = 16)]], aes(x = PSI)) + geom_histogram(color = 'white', binwidth = .05) + theme_bw() + facet_wrap(. ~ IHEC)

for (var_threshold in names(var_events)) {
  cor_dt <- se_dt[ID %in% var_events[[var_threshold]], lapply(.SD[, -c('ID', 'PSI')], function(y) suppressWarnings(cor(y, PSI, use = 'na', method = cor_method))), by = 'IHEC']
  max_cor_cols <- keep_cols(cor_dt, aggregation)
  
  cor_dt_intermediate <- cor_dt[, ..max_cor_cols]
  colnames(cor_dt_intermediate) <- gsub('_max', '', colnames(cor_dt_intermediate), fixed = TRUE)
  cor_mat <- as.matrix(cor_dt_intermediate[, -'IHEC'])
  rownames(cor_mat) <- cor_dt_intermediate[, IHEC]
  breaks <- seq(-.2, .2, by = .01)
  annotation_df <- metadata[EpiRR_no_version %in% sample_cols, data.frame(annotation = annotation, row.names = EpiRR_no_version)]
  pheatmap(t(cor_mat[sample_cols, ])[, rownames(annotation_df)[order(annotation_df$annotation)]], color = colorRampPalette(c("red", "white", "blue"))(length(breaks)), breaks = breaks, annotation_col = annotation_df, cluster_cols = FALSE, main = paste('PSI Variance Quantile:', var_threshold))
  melt_cor_dt <- melt(cor_dt_intermediate, id.vars = 'IHEC', variable.name = 'feature', value.name = 'correlation w/ PSI')
  melt_cor_dt[, median_cor:=median(`correlation w/ PSI`, na.rm = TRUE), by = feature]
  print(ggplot(melt_cor_dt, aes(y = `correlation w/ PSI`, x = reorder(feature, -`correlation w/ PSI`, FUN = median, na.rm = TRUE))) + theme_bw() + geom_boxplot(aes(fill = median_cor)) + theme(axis.text.x = element_text(angle = 90, hjust=1)) + scale_fill_gradientn(colours = colorRampPalette(c("red", "white", "blue"))(length(breaks)), breaks = seq(-.2, .2, by = .1), limits = c(-.2, .2)) + xlab('feature') + ggtitle(paste('PSI Variance Quantile:', var_threshold)))
}
```

```{r, eval = FALSE}
se_max_cols <- keep_cols(se_dt, aggregation)
feature_data <- se_dt[, ..se_max_cols][, -c('IHEC', 'ID')]
response <- 'PSI'
explanatory <- names(feature_data)[names(feature_data) != response]
feature_data[, (names(feature_data)) := lapply(names(feature_data), function(x) scale(get(x)))]
linear_model <- lm(formula(paste(response, '~', paste(explanatory, collapse = ' + '))), feature_data)
summary(linear_model)
```
